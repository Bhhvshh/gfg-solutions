// Problem: Java_Easy_Optimized_Code
// Description: Editorial View Author's Solution The following is a GFG article that can be used to understand the concepts used in this problem. It may or may not be exactly applicable to the problem statement given here. Given an array arr[] consisting of n integers, find all the array elements which occurs more than floor(n/3) times.
Note: The returned array of majority elements should be sorted. Examples: Input: arr[] = [2, 2, 3, 1, 3, 2, 1, 1]
Output: [1, 2]
Explanation: The frequency of 1 and 2 is 3, which is more than floor n/3 (8/3 = 2). Input: arr[] = [-5, 3, -5]
Output: [-5]
Explanation: The frequency of -5 is 2, which is more than floor n/3 (3/3 = 1). Input: arr[] = [3, 2, 2, 4, 1, 4]
Output: [ ]
Explanation: There is no majority element. Table of Content [Naive Approach] Using Nested Loops - O(n^2) Time and O(1) Space[Better Approach] Using Hash Map or Dictionary - O(n) Time and O(n) Space[Expected Approach] Boyer-Moore’s Voting Algorithm - O(n) Time and O(1) Space
[Naive Approach] Using Nested Loops - O(n^2) Time and O(1) SpaceThe idea is to iterate over all elements and count the frequency of the element in the array. If the frequency of the element is greater than floor(n/3), add it to the result. To avoid adding duplicate elements into the result, we can check if the element is already present in the result. We can stop the iteration if we have already found two majority elements. C++ #include <iostream>
#include <vector>
using namespace std; vector<int> findMajority(vector<int> &arr) { int n = arr.size(); vector<int> res; for (int i = 0; i < n; i++) { // Count the frequency of arr[i] int cnt = 0; for (int j = i; j < n; j++) { if (arr[j] == arr[i]) cnt += 1; } // Check if arr[i] is a majority element if (cnt > (n / 3)) { // Add arr[i] only if it is not already // present in the result if (res.size() == 0 || arr[i] != res[0]) { res.push_back(arr[i]); } } // If we have found two majority elements, // we can stop our search if (res.size() == 2) { if(res[0] > res[1]) swap(res[0], res[1]); break; } } return res;
} int main() { vector<int> arr = {2, 2, 3, 1, 3, 2, 1, 1}; vector<int> res = findMajority(arr); for (int ele : res) cout << ele << " "; return 0;
} #include <iostream>
#include <vector>using namespace std;​vector<int> findMajority(vector<int> &arr) { int n = arr.size(); vector<int> res;​ for (int i = 0; i < n; i++) { // Count the frequency of arr[i] int cnt = 0; for (int j = i; j < n; j++) { if (arr[j] == arr[i]) cnt += 1; } // Check if arr[i] is a majority element if (cnt > (n / 3)) { // Add arr[i] only if it is not already // present in the result if (res.size() == 0 || arr[i] != res[0]) { res.push_back(arr[i]); } } // If we have found two majority elements, // we can stop our search if (res.size() == 2) { if(res[0] > res[1]) swap(res[0], res[1]); break; } }​ return res;}​int main() { vector<int> arr = {2, 2, 3, 1, 3, 2, 1, 1}; vector<int> res = findMajority(arr); for (int ele : res) cout << ele << " "; return 0;} C #include <stdio.h> int *findMajority(int *arr, int n, int *resSize) { int *res = (int *)malloc(2 * sizeof(int)); *resSize = 0; for (int i = 0; i < n; i++) { // Count the frequency of arr[i] int cnt = 0; for (int j = i; j < n; j++) { if (arr[j] == arr[i]) cnt += 1; } // Check if arr[i] is a majority element if (cnt > (n / 3)) { // Add arr[i] only if it is not already // present in the result if (*resSize == 0 || arr[i] != res[0]) { res[*resSize] = arr[i]; (*resSize)++; } } // If we have found two majority elements, // we can stop our search if (*resSize == 2) { if (res[0] > res[1]) { int temp = res[0]; res[0] = res[1]; res[1] = temp; } break; } } return res;
} int main() { int arr[] = {2, 2, 3, 1, 3, 2, 1, 1}; int n = sizeof(arr) / sizeof(arr[0]); int resSize; int *res = findMajority(arr, n, &resSize); for (int i = 0; i < resSize; i++) printf("%d ", res[i]); return 0;
} Java import java.util.ArrayList; class GfG { static ArrayList<Integer> findMajority(int[] arr) { int n = arr.length; ArrayList<Integer> res = new ArrayList<>(); for (int i = 0; i < n; i++) { // Count the frequency of arr[i] int cnt = 0; for (int j = i; j < n; j++) { if (arr[j] == arr[i]) cnt += 1; } // Check if arr[i] is a majority element if (cnt > (n / 3)) { // Add arr[i] only if it is not already present if (res.size() == 0 || arr[i] != res.get(0)) { res.add(arr[i]); } } // If we have found two majority elements, // we can stop our search if (res.size() == 2) { if (res.get(0) > res.get(1)) java.util.Collections.swap(res, 0, 1); break; } } return res; } public static void main(String[] args) { int[] arr = {2, 2, 3, 1, 3, 2, 1, 1}; ArrayList<Integer> res = findMajority(arr); for (int ele : res) System.out.print(ele + " "); }
} Python def findMajority(arr): n = len(arr) res = [] for i in range(n): # Count the frequency of arr[i] cnt = 0 for j in range(i, n): if arr[j] == arr[i]: cnt += 1 # Check if arr[i] is a majority element if cnt > (n // 3): # Add arr[i] only if it is not already # present in the result if len(res) == 0 or arr[i] != res[0]: res.append(arr[i]) # If we have found two majority elements, # we can stop our search if len(res) == 2: if res[0] > res[1]: res[0], res[1] = res[1], res[0] break return res if __name__ == "__main__": arr = [2, 2, 3, 1, 3, 2, 1, 1] res = findMajority(arr) for ele in res: print(ele, end=" ") C# using System;
using System.Collections.Generic; class GfG { static List<int> findMajority(int[] arr) { int n = arr.Length; List<int> res = new List<int>(); for (int i = 0; i < n; i++) { // Count the frequency of arr[i] int cnt = 0; for (int j = i; j < n; j++) { if (arr[j] == arr[i]) cnt += 1; } // Check if arr[i] is a majority element if (cnt > (n / 3)) { // Add arr[i] only if it is not already // present in the result if (res.Count == 0 || arr[i] != res[0]) { res.Add(arr[i]); } } // If we have found two majority elements, // we can stop our search if (res.Count == 2) { if (res[0] > res[1]) { int temp = res[0]; res[0] = res[1]; res[1] = temp; } break; } } return res; } static void Main(string[] args) { int[] arr = { 2, 2, 3, 1, 3, 2, 1, 1 }; List<int> res = findMajority(arr); foreach (int ele in res) Console.Write(ele + " "); }
} JavaScript function findMajority(arr) { const n = arr.length; const res = []; for (let i = 0; i < n; i++) { // Count the frequency of arr[i] let cnt = 0; for (let j = i; j < n; j++) { if (arr[j] === arr[i]) { cnt += 1; } } // Check if arr[i] is a majority element if (cnt > (n / 3)) { // Add arr[i] only if it is not already // present in the result if (res.length === 0 || arr[i] !== res[0]) { res.push(arr[i]); } } // If we have found two majority elements, // we can stop our search if (res.length === 2) { if (res[0] > res[1]) { [res[0], res[1]] = [res[1], res[0]]; } break; } } return res;
} // Driver Code
const arr = [2, 2, 3, 1, 3, 2, 1, 1];
const res = findMajority(arr);
console.log(res.join(" ")); Output1 2 [Better Approach] Using Hash Map or Dictionary - O(n) Time and O(n) SpaceThe idea is to use a hash map or dictionary to count the frequency of each element in the array. After counting, iterate over the hash map and if the frequency of any element is greater than (n/3), push it into the result. Finally, the majority elements are returned after sorting. C++ #include <iostream>
#include <unordered_map>
#include <vector>
using namespace std; vector<int> findMajority(vector<int> &arr) { int n = arr.size(); unordered_map<int, int> freq; vector<int> res; // find frequency of each number for (int ele : arr) freq[ele]++; // Iterate over each key-value pair // in the hash map for (auto it : freq) { int ele = it.first; int cnt = it.second; // Add the element to the result, if its frequency // if greater than floor(n/3) if (cnt > n / 3) res.push_back(ele); } if (res.size() == 2 && res[0] > res[1]) swap(res[0], res[1]); return res;
} int main() { vector<int> arr = {2, 2, 3, 1, 3, 2, 1, 1}; vector<int> res = findMajority(arr); for (auto ele : res) { cout << ele << " "; } return 0;
} #include <iostream>
#include <unordered_map>#include <vector>using namespace std;​vector<int> findMajority(vector<int> &arr) { int n = arr.size(); unordered_map<int, int> freq; vector<int> res;​ // find frequency of each number for (int ele : arr) freq[ele]++;​ // Iterate over each key-value pair // in the hash map for (auto it : freq) { int ele = it.first; int cnt = it.second;​ // Add the element to the result, if its frequency // if greater than floor(n/3) if (cnt > n / 3) res.push_back(ele); }​ if (res.size() == 2 && res[0] > res[1]) swap(res[0], res[1]); return res;}​int main() {​ vector<int> arr = {2, 2, 3, 1, 3, 2, 1, 1}; vector<int> res = findMajority(arr); for (auto ele : res) { cout << ele << " "; } return 0;} Java import java.util.HashMap;
import java.util.ArrayList;
import java.util.Map; class GfG { static ArrayList<Integer> findMajority(int[] arr) { int n = arr.length; HashMap<Integer, Integer> freq = new HashMap<>(); ArrayList<Integer> res = new ArrayList<>(); // find frequency of each number for (int ele : arr) freq.put(ele, freq.getOrDefault(ele, 0) + 1); // Iterate over each key-value // pair in the hash map for (Map.Entry<Integer, Integer> it : freq.entrySet()) { int ele = it.getKey(); int cnt = it.getValue(); // Add the element to the result if its // frequency is greater than n / 3 if (cnt > n / 3) res.add(ele); } // Sort result if there are two elements // and they are out of order if (res.size() == 2 && res.get(0) > res.get(1)) { int temp = res.get(0); res.set(0, res.get(1)); res.set(1, temp); } return res; } public static void main(String[] args) { int[] arr = {2, 2, 3, 1, 3, 2, 1, 1}; ArrayList<Integer> res = findMajority(arr); for (int ele : res) { System.out.print(ele + " "); } }
} Python def findMajority(arr): n = len(arr) freq = {} res = [] # find frequency of each number for ele in arr: freq[ele] = freq.get(ele, 0) + 1 # Iterate over each key-value # pair in the hash map for ele, cnt in freq.items(): # Add the element to the result, if its frequency # is greater than floor(n/3) if cnt > n // 3: res.append(ele) if len(res) == 2 and res[0] > res[1]: res[0], res[1] = res[1], res[0] return res if __name__ == "__main__": arr = [2, 2, 3, 1, 3, 2, 1, 1] res = findMajority(arr) for ele in res: print(ele, end=" ") C# using System;
using System.Collections.Generic; class GfG { static List<int> findMajority(int[] arr) { int n = arr.Length; Dictionary<int, int> freq = new Dictionary<int, int>(); List<int> res = new List<int>(); // find frequency of each number foreach (int ele in arr) { if (freq.ContainsKey(ele)) freq[ele]++; else freq[ele] = 1; } // Iterate over each key-value // pair in the hash map foreach (var it in freq) { int ele = it.Key; int cnt = it.Value; // Add the element to the result, if its frequency // is greater than floor(n/3) if (cnt > n / 3) res.Add(ele); } if (res.Count == 2 && res[0] > res[1]) { int temp = res[0]; res[0] = res[1]; res[1] = temp; } return res; } static void Main() { int[] arr = { 2, 2, 3, 1, 3, 2, 1, 1 }; List<int> res = findMajority(arr); foreach (int ele in res) { Console.Write(ele + " "); } }
} JavaScript function findMajority(arr) { const n = arr.length; const freq = {}; const res = []; // find frequency of each number for (const ele of arr) { freq[ele] = (freq[ele] || 0) + 1; } // Iterate over each key-value pair in the hash map for (const it in freq) { const ele = Number(it); const cnt = freq[it]; // Add the element to the result, if its frequency // is greater than floor(n/3) if (cnt > Math.floor(n / 3)) { res.push(ele); } } if (res.length === 2 && res[0] > res[1]) { [res[0], res[1]] = [res[1], res[0]]; } return res;
} // Driver Code
const arr = [2, 2, 3, 1, 3, 2, 1, 1];
const res = findMajority(arr);
console.log(res.join(" ")); Output1 2 [Expected Approach] Boyer-Moore’s Voting Algorithm - O(n) Time and O(1) SpaceThe idea is based on the observation that there can be at most two majority elements, which appear more than n/3 times. so we can use Boyer-Moore’s Voting algorithm. As we iterate the array, We identify potential majority elements by keeping track of two candidates and their respective counts. Steps: Initialize two variables ele1 = -1 and ele2 = -1, for candidates and two variables cnt1 = 0 and cnt2 = 0, for counting.In each iteration, If an element is equal to any candidate, update that candidate's count.If count of a candidate reaches zero then replace that candidate with current element.If neither candidate matches and both counts are non zero, decrement the counts.After this, in second pass we check if the chosen candidates appear more than n/3 times in the array. If they do then include them in result array.Since any element than appears more than floor(n/3) times, will dominate over elements that appear less frequently. Whenever we encounter a different element, we decrement the count of both the candidates. This maintains at most two candidates in the array. Previous Pause Next 9 / 10 C++ #include <iostream>
#include <vector>
#include <algorithm>
#include <limits.h>
using namespace std; vector<int> findMajority(vector<int> &arr) { int n = arr.size(); // Initialize two candidates and their counts int ele1 = -1, ele2 = -1, cnt1 = 0, cnt2 = 0; for (int ele : arr) { // Increment count for candidate 1 if (ele1 == ele) { cnt1++; } // Increment count for candidate 2 else if (ele2 == ele) { cnt2++; } // New candidate 1 if count is zero else if (cnt1 == 0) { ele1 = ele; cnt1++; } // New candidate 2 if count is zero else if (cnt2 == 0) { ele2 = ele; cnt2++; } // Decrease counts if neither candidate else { cnt1--; cnt2--; } } vector<int> res; cnt1 = 0; cnt2 = 0; // Count the occurrences of candidates for (int ele : arr) { if (ele1 == ele) cnt1++; if (ele2 == ele) cnt2++; } // Add to result if they are majority elements if (cnt1 > n / 3) res.push_back(ele1); if (cnt2 > n / 3 && ele1 != ele2) res.push_back(ele2); if(res.size() == 2 && res[0] > res[1]) swap(res[0], res[1]); return res;
} int main() { vector<int> arr = {2, 2, 3, 1, 3, 2, 1, 1}; vector<int> res = findMajority(arr); for (int ele : res) { cout << ele << " "; } return 0;
} #include <iostream>
#include <vector>#include <algorithm>#include <limits.h>using namespace std;​vector<int> findMajority(vector<int> &arr) { int n = arr.size();​ // Initialize two candidates and their counts int ele1 = -1, ele2 = -1, cnt1 = 0, cnt2 = 0;​ for (int ele : arr) { // Increment count for candidate 1 if (ele1 == ele) { cnt1++; } // Increment count for candidate 2 else if (ele2 == ele) { cnt2++; } // New candidate 1 if count is zero else if (cnt1 == 0) { ele1 = ele; cnt1++; } // New candidate 2 if count is zero else if (cnt2 == 0) { ele2 = ele; cnt2++; } // Decrease counts if neither candidate else { cnt1--; cnt2--; } }​ vector<int> res; cnt1 = 0; cnt2 = 0;​ // Count the occurrences of candidates for (int ele : arr) { if (ele1 == ele) cnt1++; if (ele2 == ele) cnt2++; }​ // Add to result if they are majority elements if (cnt1 > n / 3) res.push_back(ele1); if (cnt2 > n / 3 && ele1 != ele2) res.push_back(ele2); if(res.size() == 2 && res[0] > res[1]) swap(res[0], res[1]); return res;}​int main() { vector<int> arr = {2, 2, 3, 1, 3, 2, 1, 1}; vector<int> res = findMajority(arr); for (int ele : res) { cout << ele << " "; } return 0;} C #include <stdio.h>
#include <limits.h> void findMajority(int arr[], int n, int *res, int *resSize) { // Initialize two candidates and their counts int ele1 = -1, ele2 = -1, cnt1 = 0, cnt2 = 0; for (int i = 0; i < n; i++) { int ele = arr[i]; // Increment count for candidate 1 if (ele1 == ele) { cnt1++; } // Increment count for candidate 2 else if (ele2 == ele) { cnt2++; } // New candidate 1 if count is zero else if (cnt1 == 0) { ele1 = ele; cnt1++; } // New candidate 2 if count is zero else if (cnt2 == 0) { ele2 = ele; cnt2++; } // Decrease counts if neither candidate else { cnt1--; cnt2--; } } cnt1 = 0; cnt2 = 0; // Count the occurrences of candidates for (int i = 0; i < n; i++) { int ele = arr[i]; if (ele1 == ele) cnt1++; if (ele2 == ele) cnt2++; } // Add to result if they are majority elements *resSize = 0; if (cnt1 > n / 3) res[(*resSize)++] = ele1; if (cnt2 > n / 3 && ele1 != ele2) res[(*resSize)++] = ele2; // Sort the result if there are two elements if (*resSize == 2 && res[0] > res[1]) { int temp = res[0]; res[0] = res[1]; res[1] = temp; }
} int main() { int arr[] = {2, 2, 3, 1, 3, 2, 1, 1}; int n = sizeof(arr) / sizeof(arr[0]); int res[2]; int resSize; findMajority(arr, n, res, &resSize); for (int i = 0; i < resSize; i++) { printf("%d ", res[i]); } return 0;
} Java import java.util.ArrayList; class GfG { // Function to find Majority element in an array static ArrayList<Integer> findMajority(int[] arr) { int n = arr.length; // Initialize two candidates and their counts int ele1 = -1, ele2 = -1; int cnt1 = 0, cnt2 = 0; for (int ele : arr) { // Increment count for candidate 1 if (ele1 == ele) { cnt1++; } // Increment count for candidate 2 else if (ele2 == ele) { cnt2++; } // New candidate 1 if count is zero else if (cnt1 == 0) { ele1 = ele; cnt1++; } // New candidate 2 if count is zero else if (cnt2 == 0) { ele2 = ele; cnt2++; } // Decrease counts if neither candidate else { cnt1--; cnt2--; } } ArrayList<Integer> res = new ArrayList<>(); cnt1 = 0; cnt2 = 0; // Count the occurrences of candidates for (int ele : arr) { if (ele1 == ele) cnt1++; if (ele2 == ele) cnt2++; } // Add to result if they are majority elements if (cnt1 > n / 3) res.add(ele1); if (cnt2 > n / 3 && ele1 != ele2) res.add(ele2); // Sort the result if needed if (res.size() == 2 && res.get(0) > res.get(1)) { int temp = res.get(0); res.set(0, res.get(1)); res.set(1, temp); } return res; } public static void main(String[] args) { int[] arr = {2, 2, 3, 1, 3, 2, 1, 1}; ArrayList<Integer> res = findMajority(arr); for (int ele : res) { System.out.print(ele + " "); } }
} Python def findMajority(arr): n = len(arr) # Initialize two candidates and their counts ele1, ele2 = -1, -1 cnt1, cnt2 = 0, 0 for ele in arr: # Increment count for candidate 1 if ele1 == ele: cnt1 += 1 # Increment count for candidate 2 elif ele2 == ele: cnt2 += 1 # New candidate 1 if count is zero elif cnt1 == 0: ele1 = ele cnt1 += 1 # New candidate 2 if count is zero elif cnt2 == 0: ele2 = ele cnt2 += 1 # Decrease counts if neither candidate else: cnt1 -= 1 cnt2 -= 1 res = [] cnt1, cnt2 = 0, 0 # Count the occurrences of candidates for ele in arr: if ele1 == ele: cnt1 += 1 if ele2 == ele: cnt2 += 1 # Add to result if they are majority elements if cnt1 > n / 3: res.append(ele1) if cnt2 > n / 3 and ele1 != ele2: res.append(ele2) if len(res) == 2 and res[0] > res[1]: res[0], res[1] = res[1], res[0] return res if __name__ == "__main__": arr = [2, 2, 3, 1, 3, 2, 1, 1] res = findMajority(arr) for ele in res: print(ele, end = " ") C# using System;
using System.Collections.Generic; class GfG { static List<int> findMajority(int[] arr) { int n = arr.Length; // Initialize two candidates and their counts int ele1 = -1, ele2 = -1, cnt1 = 0, cnt2 = 0; foreach (int ele in arr) { // Increment count for candidate 1 if (ele1 == ele) { cnt1++; } // Increment count for candidate 2 else if (ele2 == ele) { cnt2++; } // New candidate 1 if count is zero else if (cnt1 == 0) { ele1 = ele; cnt1++; } // New candidate 2 if count is zero else if (cnt2 == 0) { ele2 = ele; cnt2++; } // Decrease counts if neither candidate else { cnt1--; cnt2--; } } List<int> res = new List<int>(); cnt1 = 0; cnt2 = 0; // Count the occurrences of candidates foreach (int ele in arr) { if (ele1 == ele) cnt1++; if (ele2 == ele) cnt2++; } // Add to result if they are majority elements if (cnt1 > n / 3) res.Add(ele1); if (cnt2 > n / 3 && ele1 != ele2) res.Add(ele2); if (res.Count == 2 && res[0] > res[1]) { int temp = res[0]; res[0] = res[1]; res[1] = temp; } return res; } static void Main() { int[] arr = { 2, 2, 3, 1, 3, 2, 1, 1 }; List<int> res = findMajority(arr); foreach (int ele in res) { Console.Write(ele + " "); } }
} JavaScript function findMajority(arr) { const n = arr.length; // Initialize two candidates and their counts let ele1 = -1, ele2 = -1; let cnt1 = 0, cnt2 = 0; for (let ele of arr) { // Increment count for candidate 1 if (ele1 === ele) { cnt1++; } // Increment count for candidate 2 else if (ele2 === ele) { cnt2++; } // New candidate 1 if count is zero else if (cnt1 === 0) { ele1 = ele; cnt1++; } // New candidate 2 if count is zero else if (cnt2 === 0) { ele2 = ele; cnt2++; } // Decrease counts if neither candidate else { cnt1--; cnt2--; } } const res = []; cnt1 = 0; cnt2 = 0; // Count the occurrences of candidates for (let ele of arr) { if (ele1 === ele) cnt1++; if (ele2 === ele) cnt2++; } // Add to result if they are majority elements if (cnt1 > n / 3) res.push(ele1); if (cnt2 > n / 3 && ele1 != ele2) res.push(ele2); if (res.length === 2 && res[0] > res[1]) { [res[0], res[1]] = [res[1], res[0]]; } return res;
} // Driver Code
const arr = [2, 2, 3, 1, 3, 2, 1, 1];
const res = findMajority(arr);
console.log(res.join(" ")); Output1 2 Useful links to help you understand the concepts of this problem: https://www.geeksforgeeks.org/candidates-with-majority-vote/ Also Explore our Best Tutorials:DSA Tutorial
Python Tutorial
Java Turorial
C++ Tutorial
JavaScript Tutorial Discussions ( 333 Threads )
Most Recent Commenting as Bhavesh VaniyaComment AnonymouslySubmit Narendra Kumar9 months agoOct 03, 2024 22:39 (GMT +5:30) Medium Level Problem || C++ and JAVA code || Begineer Friendly 1. Approach ( Time->O(N) and Space->O(N) using HashMap || Though run all the testcases. vector<int> findMajority(vector<int>& nums) { vector<int>ans; unordered_map<int,int>mp; for(auto &it:nums){ mp[it]++; } for(auto it:mp){ if(it.second>(nums.size()/3)) ans.push_back(it.first); } sort(ans.begin(),ans.end()); if(ans.size()==0) return {-1}; return ans; } 2. Optimal Solution (Time->O(N) and Space->O(1) || C++ code vector<int> findMajority(vector<int>& nums) { vector<int>ans; int n=nums.size(),cand1,cand2=0,counter1=0,counter2=0; for(int i=0;i<n;i++){ if(nums[i]==cand1){ counter1++; }else if(nums[i]==cand2){ counter2++; }else if(counter1==0){ cand1=nums[i]; counter1++; }else if(counter2==0){ cand2=nums[i]; counter2++; }else { counter1--; counter2--; } } // now cand1 and cand2 is the potential winner so at last // veriry wheather they are majority element or not; int count1=0,count2=0; for(int i=0;i<n;i++){ if(nums[i]==cand1) count1++; else if(nums[i]==cand2) count2++; } if(count1>(n/3)) ans.push_back(cand1); if(count2>(n/3)) ans.push_back(cand2); // sort the elements of ans vector (there will be maximum 2 elements so no issue for the time complexity) sort(ans.begin(),ans.end()); // finally return the ans; if(ans.size()==0) return {-1}; return ans; } 3. Optimal Solution (Time->O(N) and Space->O(1) || JAVA code public List<Integer> findMajority(List<Integer> nums) { List<Integer>ans=new ArrayList<>(); int n=nums.size(),cand1=-1,cand2=-1,counter1=0,counter2=0; for(int i=0;i<n;i++){ if(nums.get(i)==cand1){ counter1++; }else if(nums.get(i)==cand2){ counter2++; }else if(counter1==0){ cand1=nums.get(i); counter1++; }else if(counter2==0){ cand2=nums.get(i); counter2++; }else { counter1--; counter2--; } } // now cand1 and cand2 is the potential winner so at last // veriry wheather they are majority element or not; int count1=0,count2=0; for(int i=0;i<n;i++){ if(nums.get(i)==cand1) count1++; else if(nums.get(i)==cand2) count2++; } if(count1>(n/3)) ans.add(cand1); if(count2>(n/3)) ans.add(cand2); // sort the elements of ans vector (there will be maximum 2 elements so no issue for the time complexity) Collections.sort(ans); // finally return the ans; if(ans.size()==0){ ans.add(-1); return ans; } return ans; } 8 Reply
(Show 2 Replies) Kartic Joshi37 minutes agoJul 26, 2025 18:02 (GMT +5:30) vector<int> findMajority(vector<int>& arr) { map <int,int> mp; vector<int> ans; for(int e:arr)mp[e]++; for(auto e:mp)if(e.second>arr.size()/3)ans.push_back(e.first); return ans; } 0 Reply Ankush Dangi Dangi53 minutes agoJul 26, 2025 17:47 (GMT +5:30) class Solution { public ArrayList<Integer> findMajority(int[] arr) { // Code here Map<Integer ,Integer> m=new HashMap<>(); int n=arr.length/3; ArrayList<Integer> l=new ArrayList<>(); for(int a:arr){ m.put(a,m.getOrDefault(a,0)+1); } for(int k:m.keySet()){ if(m.get(k)>n){ l.add(k); } } Collections.sort(l); return l; }
} 0 Reply Vishal Rathod1 hour agoJul 26, 2025 17:07 (GMT +5:30) Java || Easy & Optimized Code class Solution { public ArrayList<Integer> findMajority(int[] arr) { int candidate1 = 0, candidate2 = 0; int count1 = 0, count2 = 0; for (int num : arr) { if (num == candidate1) { count1++; } else if (num == candidate2) { count2++; } else if (count1 == 0) { candidate1 = num; count1 = 1; } else if (count2 == 0) { candidate2 = num; count2 = 1; } else { count1--; count2--; } } count1 = 0; count2 = 0; for (int num : arr) { if (num == candidate1) count1++; else if (num == candidate2) count2++; } ArrayList<Integer> result = new ArrayList<>(); int threshold = arr.length / 3; if (count1 > threshold) result.add(candidate1); if (count2 > threshold) result.add(candidate2); Collections.sort(result); return result; }
} 0 Reply surajyadav4ygd3 hours agoJul 26, 2025 15:05 (GMT +5:30) c++ sol::: vector<int> findMajority(vector<int>& arr) { map<int,int>mp; vector<int>ans; int n=arr.size()/3; for(int i=0;i<arr.size();i++){ mp[arr[i]]++; } for(auto it : mp){ if(it.second>n){ ans.push_back(it.first); } } return ans; 1 Reply Aadarsh Dangi4 hours agoJul 26, 2025 13:44 (GMT +5:30) class Solution { // Function to find the majority elements in the array public List<Integer> findMajority(int[] nums) { // Your code goes here. HashMap<Integer, Integer> map = new HashMap<>(); List<Integer> ans = new ArrayList<>(); int threshold = nums.length / 3; for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } for (Map.Entry<Integer, Integer> entry : map.entrySet()) { if (entry.getValue() > threshold) { ans.add(entry.getKey()); } } Collections.sort(ans); return ans; }
} 0 Reply Nikita Jain5 hours agoJul 26, 2025 13:11 (GMT +5:30) If there is more optimised approach then below, then kindly let me know. Time Complexity: O(nlogn) Space Complexity: O(n) class Solution { public ArrayList<Integer> findMajority(int[] arr) { ArrayList<Integer> list = new ArrayList<>(); Arrays.sort(arr); int total = arr.length/3,i=0, count=1; while(i<arr.length) { if(i==arr.length-1) { if(count>total) list.add(arr[i]); } else { if(arr[i]==arr[i+1]) count++; else { if(count>total) list.add(arr[i]); count=1; } } i++; } return list; }
} 0 Reply
(Show 1 Replies) Riddhi Agrawal5 hours agoJul 26, 2025 12:59 (GMT +5:30) JAVA SOLUTION! class Solution { public ArrayList<Integer> findMajority(int[] arr) { // Code here int n= arr.length; ArrayList <Integer> ans= new ArrayList<>(); int c= n/3, count=1; Arrays.sort(arr); for(int x=1;x<n;x++) { if(arr[x]!=arr[x-1]) { if(count>c) ans.add(arr[x-1]); count=1; } else count++; } if(count>c) ans.add(arr[n-1]); return ans; }
} 0 Reply Riddesh Kankariya6 hours agoJul 26, 2025 12:34 (GMT +5:30) Bhai Ye Mat Karna Please !!!
vector<int> findMajority(vector<int>& arr) { // Code here vector<int>ans; int x=floor((arr.size())/3); map<int, int>m; for(int i=0;i<arr.size();i++){ m[arr[i]]++; } for(auto ele:m){ if(ele.second>x) ans.push_back(ele.first); } return ans; } 1 Reply
(Show 1 Replies) Vivek6 hours agoJul 26, 2025 12:34 (GMT +5:30) Time Complexity: O(n) Space Complexity: O(1) Correct code according to sorting rule: class Solution { public: vector<int> findMajority(vector<int>& arr) { int n=arr.size(); int a=-1, b=-1, ca=0, cb=0; int mn=(int)(n/3)+1; vector<int> ans; for(int i=0; i<n; i++) { if(b!=arr[i] && ca==0) { a=arr[i]; ca++; } else if(a!=arr[i] && cb==0) { b=arr[i]; cb++; } else if(a==arr[i]) { ca++; } else if(b==arr[i]) { cb++; } else { ca--; cb--; } } ca=0, cb=0; for(int i=0; i<n; i++) { if(arr[i]==a) ca++; if(arr[i]==b) cb++; } if(ca>=mn) ans.push_back(a); if(cb>=mn) ans.push_back(b); sort(ans.begin(), ans.end()); return ans; }
}; 2 Reply
// GeeksforGeeks Solution

int c1 = 0, c2 = 0;
        
        for(int i = 0;i<arr.size();i++){
            
            if( m1==arr[i]){
                c1++;
                m1 = arr[i];
            }
            else if( m2==arr[i]){
                c2++;
                m2 = arr[i];
            }
            
            else if(c1==0){
                c1++;
                m1 = arr[i];
                
            }
            else if(c2==0){
                c2++;
                m2 = arr[i];
                
            }
            else{
                c1--;
                c2--;
            }
        }
        vector<int> ans;
        int cv1 = 0,cv2=0;
        for(auto x:arr) if(x==m1) cv1++;
        for(auto x:arr) if(x==m2) cv2++;
        if(cv1>arr.size()/3)ans.push_back(m1);
        if(cv2>arr.size()/3)ans.push_back(m2);
        
        sort(ans.begin(),ans.end());
        
        return ans;
    }